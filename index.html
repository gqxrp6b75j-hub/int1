<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Constellation MIDI Pro</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            color: white;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none;
        }

        #app-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-size: cover;
            background-position: center;
            z-index: 1;
        }

        /* SVG Layer for Shapes */
        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            background: rgba(0, 0, 0, 0.85);
            z-index: 100;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
            border-bottom: 1px solid #333;
        }

        #ui-layer.hidden {
            display: none;
        }

        /* Buttons & Inputs */
        button, select, label, .file-btn {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            white-space: nowrap;
        }

        button:active { transform: scale(0.98); }
        
        button.mode-active {
            background: #007AFF;
            border-color: #007AFF;
        }
        
        button.draw-active {
            background: #30D158;
            border-color: #30D158;
            color: black;
        }

        #bg-input, #load-input { display: none; }

        /* SVG Shapes Styles */
        .midi-shape {
            fill: rgba(255, 255, 255, 0.15);
            stroke: rgba(255, 255, 255, 0.5);
            stroke-width: 2px;
            transition: fill 0.1s, stroke 0.1s;
            cursor: pointer;
        }

        /* Active (Pressed) State */
        .midi-shape.active {
            fill: rgba(255, 255, 255, 0.8);
            stroke: white;
            filter: drop-shadow(0 0 10px rgba(255,255,255,0.8));
        }

        /* Edit Mode Styles */
        .editing .midi-shape {
            stroke: #FF9500; /* Orange stroke in edit mode */
            stroke-dasharray: 5;
            fill: rgba(255, 149, 0, 0.1);
        }
        
        /* Drawing Preview Lines */
        .drawing-line {
            stroke: #30D158;
            stroke-width: 2px;
            fill: none;
        }
        .drawing-point {
            fill: #30D158;
        }

        /* Settings Modal */
        #modal-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 200;
            display: none;
            justify-content: center;
            align-items: center;
        }
        #modal {
            background: #222;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #444;
            min-width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        #modal h3 { margin: 0 0 5px 0; color: #eee; }

    </style>
</head>
<body>

    <!-- Background Image Container -->
    <div id="app-container"></div>

    <!-- SVG Draw Layer -->
    <svg id="svg-layer"></svg>

    <!-- Top Control Bar -->
    <div id="ui-layer">
        <button id="btn-play" class="mode-active">‚ñ∂ Play</button>
        <button id="btn-edit">‚úé Edit</button>
        <div style="width: 1px; height: 20px; background: #555; margin: 0 5px;"></div>
        
        <!-- Edit Tools (Hidden in Play Mode) -->
        <div id="edit-tools" style="display:none; gap:10px; align-items:center;">
            <button id="btn-add-circle">+ Circle</button>
            <button id="btn-draw-poly">Draw Shape</button>
            <button id="btn-finish-poly" style="display:none; background:#30D158; color:black;">Finish Shape</button>
            <span style="font-size:12px; color:#aaa;">(Drag to Move ‚Ä¢ Tap to Edit)</span>
        </div>

        <!-- System Tools -->
        <div style="flex-grow:1;"></div> <!-- Spacer -->
        
        <label for="bg-input">üì∑ BG</label>
        <input type="file" id="bg-input" accept="image/*">
        
        <select id="midi-out"><option value="">No MIDI</option></select>
        
        <button onclick="saveProject()">üíæ Save</button>
        <label for="load-input">üìÇ Load</label>
        <input type="file" id="load-input" accept=".json">
        
        <button id="btn-hide-ui">Hide</button>
    </div>
    
    <!-- Floating Gear to show UI -->
    <button id="btn-show-ui" style="position:absolute; top:10px; right:10px; z-index:99; opacity:0.5; display:none; font-size:20px; padding:5px 10px;">‚öôÔ∏è</button>

    <!-- Settings Modal -->
    <div id="modal-overlay">
        <div id="modal">
            <h3>Button Settings</h3>
            <label>MIDI Note: <input type="number" id="modal-note" style="width:60px; background:#333; color:white; border:1px solid #555; padding:5px;"></label>
            <div style="display:flex; gap:10px; margin-top:10px;">
                <button id="modal-save" style="background:#007AFF; flex:1;">Update</button>
                <button id="modal-delete" style="background:#FF3B30; flex:1;">Delete</button>
            </div>
            <button id="modal-cancel" style="margin-top:5px;">Cancel</button>
        </div>
    </div>

    <script>
        // --- State Variables ---
        let mode = 'play'; // 'play', 'edit', 'drawing'
        let shapes = [];   // Array to store shape data object {id, type, points, x, y, note}
        let nextId = 1;
        let nextNote = 60;
        let midiOutput = null;
        
        // Drawing State
        let drawPoints = []; 
        let tempPolyline = null; // SVG element for previewing drawing
        
        // Dragging State
        let selectedShapeId = null;
        let isDragging = false;
        let dragStart = { x:0, y:0 };
        let initialShapePos = { x:0, y:0, points: [] }; // Store initial state before drag

        // DOM Elements
        const svgLayer = document.getElementById('svg-layer');
        const appContainer = document.getElementById('app-container');
        const uiLayer = document.getElementById('ui-layer');
        const editTools = document.getElementById('edit-tools');
        
        // --- MIDI Setup ---
        if (navigator.requestMIDIAccess) {
            navigator.requestMIDIAccess().then(onMIDISuccess, () => console.warn("MIDI Fail"));
        }

        function onMIDISuccess(midiAccess) {
            const select = document.getElementById('midi-out');
            select.innerHTML = '<option value="">Select Output</option>';
            midiAccess.outputs.forEach(output => {
                const opt = document.createElement('option');
                opt.value = output.id;
                opt.innerText = output.name;
                select.appendChild(opt);
            });
            select.onchange = () => midiOutput = midiAccess.outputs.get(select.value);
        }

        function sendMidi(note, on) {
            if (!midiOutput) return;
            const msg = on ? [0x90, note, 0x7F] : [0x80, note, 0x40];
            midiOutput.send(msg);
        }

        // --- Interaction Handling ---

        // 1. Switch Modes
        document.getElementById('btn-play').onclick = () => setMode('play');
        document.getElementById('btn-edit').onclick = () => setMode('edit');

        function setMode(newMode) {
            mode = newMode;
            document.body.className = (mode === 'edit' || mode === 'drawing') ? 'editing' : '';
            
            // Toggle Buttons
            document.getElementById('btn-play').className = mode === 'play' ? 'mode-active' : '';
            document.getElementById('btn-edit').className = (mode === 'edit' || mode === 'drawing') ? 'mode-active' : '';
            
            // Show/Hide Tools
            editTools.style.display = (mode === 'edit' || mode === 'drawing') ? 'flex' : 'none';
            
            // Reset Drawing if switching away
            if (mode !== 'drawing') resetDrawing();
        }

        // 2. Add Circle
        document.getElementById('btn-add-circle').onclick = () => {
            const cx = window.innerWidth / 2;
            const cy = window.innerHeight / 2;
            createShapeData({
                type: 'circle',
                cx: cx,
                cy: cy,
                r: 30,
                note: nextNote++
            });
        };

        // 3. Draw Polygon Tool
        document.getElementById('btn-draw-poly').onclick = () => {
            if (mode === 'drawing') {
                setMode('edit'); // Cancel draw
            } else {
                mode = 'drawing';
                document.getElementById('btn-draw-poly').className = 'draw-active';
                document.getElementById('btn-draw-poly').innerText = 'Cancel Draw';
                document.getElementById('btn-finish-poly').style.display = 'inline-block';
                drawPoints = [];
            }
        };

        document.getElementById('btn-finish-poly').onclick = () => {
            if (drawPoints.length < 3) {
                alert("Tap at least 3 points to make a shape.");
                return;
            }
            createShapeData({
                type: 'polygon',
                points: drawPoints, // Array of {x,y}
                note: nextNote++
            });
            setMode('edit'); // Return to edit mode
        };

        // Global Touch/Click Handler for Drawing & Deselecting
        svgLayer.addEventListener('pointerdown', (e) => {
            if (mode === 'drawing') {
                // Add point
                const pt = { x: e.clientX, y: e.clientY };
                drawPoints.push(pt);
                renderDrawingPreview();
            }
        });

        function renderDrawingPreview() {
            if (!tempPolyline) {
                tempPolyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
                tempPolyline.setAttribute("class", "drawing-line");
                svgLayer.appendChild(tempPolyline);
                
                // Add circles for points
            }
            // Update points string
            const ptsString = drawPoints.map(p => `${p.x},${p.y}`).join(" ");
            tempPolyline.setAttribute("points", ptsString);
            
            // Draw marker for latest point
            const marker = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            marker.setAttribute("cx", drawPoints[drawPoints.length-1].x);
            marker.setAttribute("cy", drawPoints[drawPoints.length-1].y);
            marker.setAttribute("r", 4);
            marker.setAttribute("class", "drawing-point");
            svgLayer.appendChild(marker);
        }

        function resetDrawing() {
            drawPoints = [];
            const previews = document.querySelectorAll('.drawing-line, .drawing-point');
            previews.forEach(el => el.remove());
            tempPolyline = null;
            document.getElementById('btn-draw-poly').className = '';
            document.getElementById('btn-draw-poly').innerText = 'Draw Shape';
            document.getElementById('btn-finish-poly').style.display = 'none';
        }

        // --- Shape Creation & Rendering ---

        function createShapeData(data) {
            const id = nextId++;
            const shape = { ...data, id: id };
            shapes.push(shape);
            renderShape(shape);
            saveToLocalStorage();
        }

        function renderShape(shapeData) {
            let el;
            if (shapeData.type === 'circle') {
                el = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                el.setAttribute("cx", shapeData.cx);
                el.setAttribute("cy", shapeData.cy);
                el.setAttribute("r", shapeData.r);
            } else {
                el = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                const pts = shapeData.points.map(p => `${p.x},${p.y}`).join(" ");
                el.setAttribute("points", pts);
            }

            el.setAttribute("class", "midi-shape");
            el.setAttribute("data-id", shapeData.id);
            el.id = "shape-" + shapeData.id;

            // Event Listeners
            addShapeEvents(el, shapeData);

            svgLayer.appendChild(el);
        }

        function addShapeEvents(el, shapeData) {
            // 1. Play Mode: Touch
            el.addEventListener('pointerdown', (e) => {
                if (mode === 'play') {
                    e.preventDefault();
                    el.classList.add('active');
                    sendMidi(shapeData.note, true);
                    el.setPointerCapture(e.pointerId); // Capture drag if they slide off
                } else if (mode === 'edit') {
                    // Start Drag logic
                    startDrag(e, shapeData);
                }
            });

            el.addEventListener('pointerup', (e) => {
                if (mode === 'play') {
                    el.classList.remove('active');
                    sendMidi(shapeData.note, false);
                    el.releasePointerCapture(e.pointerId);
                } else if (mode === 'edit') {
                    if (!isDragging) {
                        // It was a click, open settings
                        openSettings(shapeData);
                    }
                    stopDrag();
                }
            });
            
            el.addEventListener('pointercancel', (e) => {
                 if(mode === 'play') {
                     el.classList.remove('active');
                     sendMidi(shapeData.note, false);
                 }
            });

            // Drag Move
            el.addEventListener('pointermove', (e) => {
                 if(mode === 'edit' && selectedShapeId === shapeData.id) {
                     doDrag(e);
                 }
            });
        }

        // --- Drag Logic ---
        function startDrag(e, shapeData) {
            isDragging = false; // Will become true if moved > 5px
            selectedShapeId = shapeData.id;
            dragStart = { x: e.clientX, y: e.clientY };
            
            // Deep copy initial state
            if (shapeData.type === 'circle') {
                initialShapePos = { cx: shapeData.cx, cy: shapeData.cy };
            } else {
                initialShapePos = { points: JSON.parse(JSON.stringify(shapeData.points)) };
            }
            
            const el = document.getElementById("shape-"+shapeData.id);
            el.setPointerCapture(e.pointerId);
        }

        function doDrag(e) {
            const dx = e.clientX - dragStart.x;
            const dy = e.clientY - dragStart.y;

            // Threshold to prevent accidental drags when tapping
            if (Math.abs(dx) > 3 || Math.abs(dy) > 3) isDragging = true;
            if (!isDragging) return;

            const shape = shapes.find(s => s.id === selectedShapeId);
            const el = document.getElementById("shape-"+selectedShapeId);

            if (shape.type === 'circle') {
                shape.cx = initialShapePos.cx + dx;
                shape.cy = initialShapePos.cy + dy;
                el.setAttribute("cx", shape.cx);
                el.setAttribute("cy", shape.cy);
            } else {
                // Update all polygon points
                shape.points = initialShapePos.points.map(p => ({
                    x: p.x + dx,
                    y: p.y + dy
                }));
                const pts = shape.points.map(p => `${p.x},${p.y}`).join(" ");
                el.setAttribute("points", pts);
            }
        }

        function stopDrag() {
            if(isDragging) saveToLocalStorage();
            selectedShapeId = null;
        }

        // --- Settings Modal ---
        const modal = document.getElementById('modal-overlay');
        const modalNoteInput = document.getElementById('modal-note');
        let currentEditingShape = null;

        function openSettings(shape) {
            currentEditingShape = shape;
            modalNoteInput.value = shape.note;
            modal.style.display = 'flex';
        }

        document.getElementById('modal-cancel').onclick = () => modal.style.display = 'none';
        
        document.getElementById('modal-save').onclick = () => {
            if (currentEditingShape) {
                currentEditingShape.note = parseInt(modalNoteInput.value);
                saveToLocalStorage();
            }
            modal.style.display = 'none';
        };
        
        document.getElementById('modal-delete').onclick = () => {
            if (confirm("Delete this button?")) {
                shapes = shapes.filter(s => s.id !== currentEditingShape.id);
                document.getElementById("shape-" + currentEditingShape.id).remove();
                saveToLocalStorage();
                modal.style.display = 'none';
            }
        };

        // --- File & Storage Logic ---

        function saveToLocalStorage() {
            const data = {
                bg: appContainer.style.backgroundImage,
                shapes: shapes
            };
            localStorage.setItem('constellationMidiPro', JSON.stringify(data));
        }

        function loadFromLocalStorage() {
            const raw = localStorage.getItem('constellationMidiPro');
            if (raw) {
                const data = JSON.parse(raw);
                if (data.bg) appContainer.style.backgroundImage = data.bg;
                if (data.shapes) {
                    shapes = [];
                    svgLayer.innerHTML = ''; // Clear SVG
                    data.shapes.forEach(s => {
                         // Assign new internal IDs to avoid conflicts or just use stored
                         nextId = Math.max(nextId, s.id + 1);
                         shapes.push(s);
                         renderShape(s);
                    });
                }
            }
        }

        // Export to File
        window.saveProject = function() {
            const data = {
                shapes: shapes
                // Note: We cannot save the BG image file content easily to JSON without Bloating it (Base64).
                // For portability, we only save the layout positions.
            };
            const blob = new Blob([JSON.stringify(data)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'constellation-layout.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        };

        // Import from File
        document.getElementById('load-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    if (confirm("Load this layout? Current shapes will be replaced.")) {
                        shapes = [];
                        svgLayer.innerHTML = '';
                        data.shapes.forEach(s => {
                             nextId = Math.max(nextId, s.id + 1);
                             shapes.push(s);
                             renderShape(s);
                        });
                        saveToLocalStorage();
                    }
                } catch (err) {
                    alert("Error loading file");
                }
            };
            reader.readAsText(file);
        });

        // Background Loader
        document.getElementById('bg-input').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(event) {
                    appContainer.style.backgroundImage = `url(${event.target.result})`;
                    saveToLocalStorage(); // This saves Base64 string to local storage (might be large!)
                };
                reader.readAsDataURL(file);
            }
        });

        // UI Toggle
        document.getElementById('btn-hide-ui').onclick = () => {
            uiLayer.style.display = 'none';
            document.getElementById('btn-show-ui').style.display = 'block';
        };
        document.getElementById('btn-show-ui').onclick = () => {
            uiLayer.style.display = 'flex';
            document.getElementById('btn-show-ui').style.display = 'none';
        };

        // --- Init ---
        loadFromLocalStorage();

    </script>
</body>
</html>
